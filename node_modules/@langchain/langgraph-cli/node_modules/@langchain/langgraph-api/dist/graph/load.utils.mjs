import { Worker } from "node:worker_threads";
import * as fs from "node:fs/promises";
import * as path from "node:path";
import { fileURLToPath, pathToFileURL } from "node:url";
import * as uuid from "uuid";
export const GRAPHS = {};
export const NAMESPACE_GRAPH = uuid.parse("6ba7b821-9dad-11d1-80b4-00c04fd430c8");
export async function resolveGraph(spec, options) {
    const [userFile, exportSymbol] = spec.split(":", 2);
    const sourceFile = path.resolve(options.cwd, userFile);
    // validate file exists
    await fs.stat(sourceFile);
    if (options?.onlyFilePresence) {
        return { sourceFile: userFile, exportSymbol, resolved: undefined };
    }
    const isGraph = (graph) => {
        if (typeof graph !== "object" || graph == null)
            return false;
        return "compile" in graph && typeof graph.compile === "function";
    };
    const graph = await import(pathToFileURL(sourceFile).toString()).then((module) => module[exportSymbol || "default"]);
    // obtain the graph, and if not compiled, compile it
    const resolved = await (async () => {
        if (!graph)
            throw new Error("Failed to load graph: graph is nullush");
        const graphLike = typeof graph === "function" ? await graph() : await graph;
        if (isGraph(graphLike))
            return graphLike.compile();
        return graphLike;
    })();
    return { sourceFile, exportSymbol, resolved };
}
export async function runGraphSchemaWorker(spec) {
    const SCHEMA_RESOLVE_TIMEOUT_MS = 30_000;
    return await new Promise((resolve, reject) => {
        const worker = new Worker(fileURLToPath(new URL("./parser/parser.worker.mjs", import.meta.url)));
        // Set a timeout to reject if the worker takes too long
        const timeoutId = setTimeout(() => {
            worker.terminate();
            reject(new Error("Schema extract worker timed out"));
        }, SCHEMA_RESOLVE_TIMEOUT_MS);
        worker.on("message", (result) => {
            worker.terminate();
            clearTimeout(timeoutId);
            resolve(result);
        });
        worker.on("error", reject);
        worker.postMessage(spec);
    });
}
